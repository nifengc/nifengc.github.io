[{"title":"技术松鼠症","path":"/2025/02/15/技术松鼠症/","content":"“技术松鼠症”是一个非正式的术语，用来形容一种在技术领域常见的行为模式：不断收集和囤积技术知识、工具或资源，但很少实际应用或深入学习。这种行为类似于松鼠囤积食物的习惯，因此被称为“技术松鼠症”,这种行为在程序员、开发者和技术爱好者中较为常见。 主要特征 囤积资源： 收集大量教程、电子书、视频课程或工具，但很少真正使用。 订阅多个技术博客、新闻源或社区，但很少深入阅读或参与讨论。 浅尝辄止： 对新技术充满兴趣，但只停留在表面了解，缺乏深入学习。 频繁切换学习方向，无法专注于某一领域。 拖延实践： 总是计划“等准备好了再开始”，但迟迟不付诸行动。 害怕失败或不确定如何开始，导致学习成果无法转化为实际能力。 焦虑与满足感错位： 通过收集资源获得短暂的满足感，但长期来看会因缺乏实际进展而感到焦虑。 容易陷入“信息过载”，感到无所适从。 产生原因 信息爆炸： 互联网时代，技术资源唾手可得，导致人们容易陷入“收集癖”。 互联网上技术资源泛滥，容易让人陷入“选择困难”。 完美主义： 总想找到“最好的资源”或“最完美的学习路径”，导致行动拖延。 总想“学完所有知识再开始”，导致拖延。 恐惧落后： 技术更新速度快，害怕错过新技术，导致盲目跟风。 害怕在实践中犯错，选择停留在理论学习阶段。 缺乏目标： 没有明确的学习目标或职业规划，导致学习方向分散。 即时满足： 收集资源比实践更容易获得即时满足感。 如何克服技术松鼠症 设定明确目标： 确定短期和长期目标，例如“掌握Java核心知识”或“完成一个完整的项目”。 将目标分解为可执行的小任务。 确定学习的具体目标（如“掌握Spring Boot并完成一个项目”），避免盲目学习。 聚焦核心技能： 选择1-2个关键技术领域深入学习，而不是盲目追求广度。 例如，专注于Java开发或前端开发，而不是同时学习多种语言。 实践驱动学习： 通过项目实践巩固知识，例如开发一个博客系统或参与开源项目。 实践是检验学习成果的最佳方式。 学完一个知识点后，立即动手实践，哪怕是一个小项目。 限制资源收集： 选择1-2个高质量的学习资源，坚持学完后再寻找新的资源。 避免同时打开多个教程或课程。 选择1-2个高质量的学习资源，坚持学完，而不是不断寻找新资源。 分解任务： 将大目标拆解为小任务，逐步完成，避免 overwhelmed（感到不堪重负）。 建立学习习惯： 每天固定时间学习，例如早上1小时或晚上2小时。 使用番茄工作法（25分钟学习+5分钟休息）提高专注力。 定期复盘： 每周或每月回顾学习进展，调整学习计划。 记录已完成的任务和学到的知识，增强成就感。 接受不完美： 允许自己在实践中犯错，从错误中学习。 总结技术松鼠症是一种常见的学习误区，表现为过度收集资源而缺乏实际行动。通过设定目标、聚焦核心技能、实践驱动学习和建立良好习惯，可以有效克服这一问题，将囤积的知识转化为实际能力。记住：学习的价值不在于你收集了多少资源，而在于你掌握了多少技能。"},{"title":"高级","path":"/2025/02/15/高级/","content":"computeIfAbsent 方法 描述：computeIfAbsent 用于获取key对应的value，如果key不存在，则将生成的值存入map中，并返回 public class MapTest public static void main(String[] args) MapString,String map = new HashMap(); map.put(key1,张三); // 如果key存在，则返回key对应的value，如果不存在，则将生成的值存入map中，并返回 System.out.println(map.computeIfAbsent(key1, k - getNum())); System.out.println(map.computeIfAbsent(key2, k - getNum())); private static String getNum() return 函数生成数据; 输出:张三函数生成数据 putIfAbsent 方法 描述：putIfAbsent 用于获取key对应的value，如果key不存在，则将存固定的值存入map中，并返回key上一个存值 public class MapTest public static void main(String[] args) MapString,String map = new HashMap(); map.put(key1,张三); System.out.println(map.putIfAbsent(key1, 存固定的值)); System.out.println(map.putIfAbsent(key2, value));//存入固定值,返回上一个存值 System.out.println(map.get(key2)); 输出:张三nullvalue"},{"title":"中级","path":"/2025/02/15/中级/","content":"computeIfAbsent 方法 描述：computeIfAbsent 用于获取key对应的value，如果key不存在，则将生成的值存入map中，并返回 public class MapTest public static void main(String[] args) MapString,String map = new HashMap(); map.put(key1,张三); // 如果key存在，则返回key对应的value，如果不存在，则将生成的值存入map中，并返回 System.out.println(map.computeIfAbsent(key1, k - getNum())); System.out.println(map.computeIfAbsent(key2, k - getNum())); private static String getNum() return 函数生成数据; 输出:张三函数生成数据 putIfAbsent 方法 描述：putIfAbsent 用于获取key对应的value，如果key不存在，则将存固定的值存入map中，并返回key上一个存值 public class MapTest public static void main(String[] args) MapString,String map = new HashMap(); map.put(key1,张三); System.out.println(map.putIfAbsent(key1, 存固定的值)); System.out.println(map.putIfAbsent(key2, value));//存入固定值,返回上一个存值 System.out.println(map.get(key2)); 输出:张三nullvalue"},{"title":"初级","path":"/2025/02/15/初级/","content":"computeIfAbsent 方法 描述：computeIfAbsent 用于获取key对应的value，如果key不存在，则将生成的值存入map中，并返回 public class MapTest public static void main(String[] args) MapString,String map = new HashMap(); map.put(key1,张三); // 如果key存在，则返回key对应的value，如果不存在，则将生成的值存入map中，并返回 System.out.println(map.computeIfAbsent(key1, k - getNum())); System.out.println(map.computeIfAbsent(key2, k - getNum())); private static String getNum() return 函数生成数据; 输出:张三函数生成数据 putIfAbsent 方法 描述：putIfAbsent 用于获取key对应的value，如果key不存在，则将存固定的值存入map中，并返回key上一个存值 public class MapTest public static void main(String[] args) MapString,String map = new HashMap(); map.put(key1,张三); System.out.println(map.putIfAbsent(key1, 存固定的值)); System.out.println(map.putIfAbsent(key2, value));//存入固定值,返回上一个存值 System.out.println(map.get(key2)); 输出:张三nullvalue"},{"title":"HashMap方法集详解","path":"/2025/02/15/HashMap/","content":"computeIfAbsent 方法 描述：computeIfAbsent 用于获取key对应的value，如果key不存在，则将生成的值存入map中，并返回 public class MapTest public static void main(String[] args) MapString,String map = new HashMap(); map.put(key1,张三); // 如果key存在，则返回key对应的value，如果不存在，则将生成的值存入map中，并返回 System.out.println(map.computeIfAbsent(key1, k - getNum())); System.out.println(map.computeIfAbsent(key2, k - getNum())); private static String getNum() return 函数生成数据; 输出:张三函数生成数据 putIfAbsent 方法 描述：putIfAbsent 用于获取key对应的value，如果key不存在，则将存固定的值存入map中，并返回key上一个存值 public class MapTest public static void main(String[] args) MapString,String map = new HashMap(); map.put(key1,张三); System.out.println(map.putIfAbsent(key1, 存固定的值)); System.out.println(map.putIfAbsent(key2, value));//存入固定值,返回上一个存值 System.out.println(map.get(key2)); 输出:张三nullvalue"},{"title":"typeScript命令行运行","path":"/2024/12/28/typeScript命令行运行/","content":"tsc xxx.ts //执行该ts文件生成.js文件node xxx.js //运行js文件输出结果"},{"title":"jdk21新特性","path":"/2024/12/28/jdk21新特性/","content":"增强的 switch 表达式 描述：switch 现在可以用作表达式，支持返回值，并支持 case 的合并及模式匹配 public class Main public static void main(String[] args) String day = MONDAY; String result = switch (day) case MONDAY, FRIDAY - Workday; case SATURDAY, SUNDAY - Weekend; default - throw new IllegalArgumentException(Unknown day); ; System.out.println(result); // 输出：Workday 虚拟线程（Virtual Threads） 虚拟线程是轻量级线程，由 JDK 管理的，可以创建大量线程而不会产生过多的资源开销 public class Main public static void main(String[] args) throws InterruptedException Thread.startVirtualThread(() - System.out.println(Hello from virtual thread); ).join(); 流（Stream API）增强 新方法：takeWhile、dropWhile、iterate 流操作新增了 takeWhile 和 dropWhile，用于基于条件筛选流元素，iterate 可以创建无限流 public class Main public static void main(String[] args) ListInteger numbers = List.of(1, 2, 3, 4, 5, 6); numbers.stream().takeWhile(n - n 4).forEach(System.out::println); // 输出 1, 2, 3 集合 API 增强 List.of、Set.of、Map.of 静态工厂方法 用于创建不可变的集合对象，简化了集合初始化的过程 public class Main public static void main(String[] args) ListString list = List.of(a, b, c); SetString set = Set.of(a, b, c); MapString, Integer map = Map.of(a, 1, b, 2); copyOf 方法用于创建现有集合的不可变副本 public class Main public static void main(String[] args) ListString list = List.of(a, b); ListString copyList = List.copyOf(list); // 创建不可变副本 新日期和时间 API JDK 8 引入了 java.time API，JDK 21 中此 API 经过改进，支持更多的日期和时间操作 public class Main public static void main(String[] args) LocalDate date = LocalDate.now(); LocalTime time = LocalTime.now(); LocalDateTime dateTime = LocalDateTime.of(date, time); 其他增强特性 public class Main public static void main(String[] args) String json = name: John, age: 30 ; Var 局部变量类型推断 public class Main public static void main(String[] args) var list = List.of(a, b, c); for (var item : list) System.out.println(item);"},{"title":"java中的大数","path":"/2024/12/28/java中的大数/","content":"BigDecimal 适用于任意精度的浮点数运算 1、add(BigDecimal val): 两个大浮点数相加 import java.math.BigDecimal;public class BigDecimalTest public static void main(String[] args) BigDecimal bigDecimal = new BigDecimal(50000000); BigDecimal bigDecimal1 = new BigDecimal(30000000); bigDecimal = bigDecimal.add(bigDecimal1); System.out.println(bigDecimal:+bigDecimal); // 结果：bigDecimal:80000000 subtract(BigDecimal val): 两个大浮点数相减 import java.math.BigDecimal;public class BigDecimalTest public static void main(String[] args) BigDecimal bigDecimal = new BigDecimal(50000000); BigDecimal bigDecimal1 = new BigDecimal(30000000); bigDecimal = bigDecimal.subtract(bigDecimal1); System.out.println(bigDecimal:+bigDecimal); // 结果：bigDecimal:20000000 multiply(BigDecimal val): 两个大浮点数相乘 import java.math.BigDecimal;public class BigDecimalTest public static void main(String[] args) BigDecimal bigDecimal = new BigDecimal(50000000); BigDecimal bigDecimal1 = new BigDecimal(30000000); bigDecimal = bigDecimal.multiply(bigDecimal1); System.out.println(bigDecimal:+bigDecimal); // 结果：bigDecimal:150000000000000000 divide(BigDecimal val, RoundingMode roundingMode): 两个大浮点数相除，结果可以指定舍入模式 import java.math.BigDecimal;public class BigDecimalTest public static void main(String[] args) BigDecimal bigDecimal = new BigDecimal(50000000); BigDecimal bigDecimal1 = new BigDecimal(30000000); bigDecimal = bigDecimal.divide(bigDecimal1, BigDecimal.ROUND_HALF_UP); System.out.println(bigDecimal:+bigDecimal); // 结果：bigDecimal:1.666666666666666666666666666666666666666666666666666666666666666666 BigInteger: 适用于任意精度的整数运算 1、add(BigInteger val): 两个大浮点数相加 import java.math.BigInteger;public class BigIntegerTest public static void main(String[] args) BigInteger BigInteger = new BigInteger(50000000); BigInteger BigInteger1 = new BigInteger(30000000); BigInteger = BigInteger.add(BigInteger1); System.out.println(BigInteger:+BigInteger); // 结果：BigInteger:80000000 subtract(BigInteger val): 两个大浮点数相减 import java.math.BigInteger;public class BigIntegerTest public static void main(String[] args) BigInteger BigInteger = new BigInteger(50000000); BigInteger BigInteger1 = new BigInteger(30000000); BigInteger = BigInteger.subtract(BigInteger1); System.out.println(BigInteger:+BigInteger); // 结果：BigInteger:20000000 multiply(BigInteger val): 两个大浮点数相乘 import java.math.BigInteger;public class BigIntegerTest public static void main(String[] args) BigInteger BigInteger = new BigInteger(50000000); BigInteger BigInteger1 = new BigInteger(30000000); BigInteger = BigInteger.multiply(BigInteger1); System.out.println(BigInteger:+BigInteger); // 结果：BigInteger:150000000000000000 divide(BigInteger val, RoundingMode roundingMode): 两个大浮点数相除，结果可以指定舍入模式 import java.math.BigInteger;public class BigIntegerTest public static void main(String[] args) BigInteger BigInteger = new BigInteger(50000000); BigInteger BigInteger1 = new BigInteger(30000000); BigInteger = BigInteger.divide(BigInteger1); System.out.println(BigInteger:+BigInteger); // 结果：BigInteger:1"},{"title":"Hello World","path":"/2024/12/28/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment"}]